---
title: "Sales Forecast"
author: "Toni Andreas Susanto"
date: "19/09/2022"
output:
  rmdformats::readthedown:
    df_print: paged
    highlight: tango
---

```{r setup, include=FALSE}
# clear-up the environment
rm(list = ls())

# chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  comment = "#>"
)

options(scipen = 999)
```

<style>
body {
text-align: justify}
</style>


# Introduction {.tabset}

## What are Time Series

Time series adalah suatu object dalam statistik dimana object tersebut berhubungan dengan suatu deret waktu tertentu. Objek ini banyak ditemui dalam kehidupan sehari-hari, contoh: harga daging sapi harian, curah hujan bulanan, kuantitas penumpang bulanan, pendapatan tahunan, dll.

## Difference with Regression

Perbedaan mendasar antara time series dengan regresi adalah jika pada regresi untuk memprediksi suatu nilai Y dipengaruhi oleh beberapa faktor yaitu x1,x2,..,xn. Sedangkan jika time series, untuk memprediksi suatu nilai Y dipengaruhi oleh nilai Y itu sendiri pada masa lampau (Ytâˆ’1).

Analisis time series berhubungan dengan suatu data yang memiliki nilai numerik pada interval waktu tertentu. Proses untuk memprediksi nilai pada anilisis time series disebut sebagai peramalan atau forecasting. Ide utama dalam melakukan forecasting itu adalah korelasi dari data numerik.

## Business Problems

PT Mobil Jaya Tbk. merupakan perusahaan otomotif mobil dari Indonesia. Perusahaan ingin mengetahui berapa perkiraan penjualan yang akan terjadi di masa mendatang. Harapannya dengan mengetahui perkiraan penjualan dimasa mendatang, perusahaan dapat mengatur target penjualan yang tepat dan realistis. Kemudian dapat mempersiapkan berbagai rencana untuk menyediakan ketersedian mobil dimasa mendatang. Lalu dapat mengatur strategi agar dapat merealisasikan nilai perkiraaan tersebut dan masih banyak lagi pemanfaatannya. Jadi kita sebagai Data Scientist diminta untuk dapat melakukan *forecasting* penjualan mobil domestik.


# Import Libraries

```{r}
library(tidyverse)
library(lubridate)
library(forecast)
library(plotly)
library(TTR)
library(fpp)
```

# Data Preprocessing

## 1. Read Dataset

```{r}
dautonsa <- read.csv("DAUTONSA.csv")
dautonsa %>% head()
```

```{r}
glimpse(dautonsa)
```

## 2. Subset Dataset

```{r}
dautonsa <- dautonsa %>% 
  mutate(DATE = as.Date(DATE)) %>% 
  filter(DATE >= "2015-01-01")
```

## 3. Range Dataset 

```{r}
dautonsa$DATE %>% range()
```

## 4. Missing Value

```{r}
is.na(dautonsa) %>% colSums()
```

## 5. Duplicate Data

```{r}
anyDuplicated(dautonsa)
```
## 6. Checking Dataset Structure

```{r}
glimpse(dautonsa)
```

# Time Series Model Preparation

## 1. Creating Time Series Object

```{r}
ts_dautonsa <- ts(data = dautonsa$DAUTONSA,
                  start = c(2015,1),
                  end = c(2019,6),
                  frequency = 12) 

ts_dautonsa %>% autoplot()
```

## 2. Decomposition

Decomposition adalah suatu tahapan dalam time series analisis yang digunakan untuk menguraikan beberapa komponen dalam time series data.

ðŸ’¡ Komponen dalam time series :

- Trend : pola data secara general, cenderung untuk naik atau turun. Jika ada trend masih terdapat pola artinya masih ada pola yang belum terurai dengan baik.
- Seasonal : pola musiman yang membentuk pola berulang pada periode waktu yang tetap
- Error/Reminder/Random : pola yang tidak dapat ditangkap dalam trend dan seasonal
Sebelum melakukan modeling forecasting kita perlu mengamati objek timeseries dari hasil decompose. Ide utama dari decompose adalah untuk menguraikan ketiga komponen dari objek ts (trend, seasonal, residual).

```{r}
decom_dautonse <- decompose(ts_dautonsa)
```

```{r}
decom_dautonse %>% autoplot() %>% ggplotly() 
```

**Insight** : 

- Trend data kita cenderung menurun.
- Data kita memiliki pola seasonal.
- Pola dataset kita dapat dikategorikan sebagai *additive seasonal* karena kenaikan yang relatif konstan, tidak multiplikasi.  

## 3. Cross Validation

```{r}
# test menggunakan `tail()`
test_dautonse <-  tail(ts_dautonsa, 18)

test_dautonse %>% autoplot()
```

> Data test kita terdiri dari Januari 2018 hingga Juli 2019 (1,5 tahun atau 18 bulan).


```{r}
# train menggunakan `head()`
train_dautonse <- head(ts_dautonsa, -length(test_dautonse))
train_dautonse %>% autoplot()
```

> Data train kita terdiri dari Januari 2015 hingga Desember 2018 (3 tahun atau 36 bulan).


# Simple Moving Average

Metode yang menggunakan rataan beregerak untuk melakukan forecasting. Karena menggunakan rataan, bobot yang digunakan sama untuk setiap observasi di masa lalu. Metode ini sering digunakan untuk data yang tidak mengandung trend dan seasonal (datanya bergerak disekitar rata-rata).

## 1. Model Building

```{r}
model_sma <- SMA(x = train_dautonse, n = 5)
```


## 2. Forecasting

```{r}
forecast_sma <- forecast(object = model_sma, h = 18)
forecast_sma
```

- Point Forecast: nilai forecast untuk periode yang ingin kita forecast
- Lo 80 & Hi 80 : rentang tebakan dari hasil forecast untuk confidence level 80%
- Lo 95 & Hi 95 : rentang tebakan dari hasil forecast untuk confidence level 95%

## 3. Visualization

```{r}
train_dautonse %>% 
  autoplot() +
  autolayer(test_dautonse, series = "Test") + # data test
    autolayer(forecast_sma$mean, series = "Forecast Data Test") + # hasil forecast model
    autolayer(model_sma, series = "Fitted Values") # fitted value data train
```

## 4. Evaluation 

```{r}
# model additive
accuracy(model_sma, train_dautonse)
```

```{r}
# evaluasi data test
accuracy(forecast_sma$mean, test_dautonse)
```

> Hasil forecast model **Simple Moving Average** dengan ordo 5 belum dapat mengikuti pola data aktualnya. Cenderung hasil prediksi masih berada ditengah kumpulam data (belum baik) meskipun selisih MAPE antara data train dan test relatif rendah dan mendekati.


# Holtâ€™s Exponential Smoothing

Metode SMA hanya mempertimbangkan n observasi di masa lampau untuk melakukan forecast baik pola trend maupun seasonal cenderung tidak tertangkap sehingga dibutuhkan metode lain yang memperhitungkan keseluruhan data di masa lampau, yaitu metode eksponensial.

Berhubung dataset kita memiliki trends dan seasonal sehingga model eksponential yang dipilih adalah Holtâ€™s Winters Exponential. Model Holtâ€™s Winters Exponential (Triple Exponential Smoothing) merupakan metode forecasting yang tepat digunakan untuk data yang memiliki efek trend dan seasonal.


## 1. Model Building

```{r}
model_holt <- HoltWinters(x = train_dautonse)
model_holt
```

## 2. Forecasting

```{r}
forecast_holt <- forecast(object = model_holt, h = 18)
forecast_holt
```

- Point Forecast: nilai forecast untuk periode yang ingin kita forecast
- Lo 80 & Hi 80 : rentang tebakan dari hasil forecast untuk confidence level 80%
- Lo 95 & Hi 95 : rentang tebakan dari hasil forecast untuk confidence level 95%


## 3. Visualization

```{r}
train_dautonse %>% 
  autoplot() +
  autolayer(test_dautonse, series = "test") + # data test
    autolayer(forecast_holt$mean, series = "forecast data test") + # hasil forecast model
    autolayer(model_holt$fitted[,1], series = "fitted values")  # fitted value data train
```

## 4. Evaluation 

```{r}
# model additive
accuracy(model_holt$fitted[,1], train_dautonse)
```

```{r}
# evaluasi data test
accuracy(forecast_holt$mean, test_dautonse)
```
> Hasil forecast model **Holtâ€™s Exponential Smoothing** sudah dapat mengikuti pola data aktualnya. Cenderung hasil prediksi sudah mengikuti pola data meskipun masih terdapat beberapa titik yang belum mendekati data aktual. Selain itu, ukuran MAPE yang dihasilkan sudah baik, train (3.65%) dan test (5.88%) serta selisih keduanya sekitar 2% alias tidak underfitting dan overfitting. 



#  Seasonal ARIMA

ARIMA (Autoregressive Integrated Moving Average), ARIMA adalah gabungan antara dua metode, yaitu Auto Regressive (AR) dan Moving Average (MA). I nya menjelaskan Integrated. Tujuan utama dari ARIMA adalah melakukan autocorrelation pada data.. Seasonal arima adalah metode arima dimana object time series yang ada memiliki pola seasonal.

## 1. Stationarity Check

```{r}
adf.test(train_dautonse)
```

> karena p-value < alpha, dimana 0.040 < 0.05 artinya data sudah stasioner.


## 2. Model Building

membuat model SARIMA menggunakan auto.arima()
SARIMA(p,d,q)(P,D,Q)[seasonal/freq]

```{r}
model_auto_sarima <- auto.arima(train_dautonse, seasonal = T)
model_auto_sarima
```

```{r}
model_auto_sarima$aic
```

## 3. Forecasting

```{r}
# forecast, h = 18
length(test_dautonse)
```

```{r}
forecast_sarima <- forecast(model_auto_sarima, h=18)
```

## 4. Visualization

```{r}
# menggunakan autoplot dan autolayer
train_dautonse %>% 
  autoplot()+
  autolayer(test_dautonse)+
  autolayer(forecast_sarima$mean)
```

## 5. Evaluation

menggunakan `accuracy()` dari package forecast dan melihat nilai MAPEnya

```{r}
# accuracy
accuracy(model_auto_sarima$fitted, train_dautonse) # error train
```

```{r}
accuracy(forecast_sarima$mean, test_dautonse) # error test
```
> Hasil forecast model **Seasonal ARIMA** sudah dapat mengikuti pola data aktualnya. Cenderung hasil prediksi sudah mengikuti pola data meskipun masih terdapat beberapa titik yang belum mendekati data aktual. Selain itu, ukuran MAPE yang dihasilkan sudah lebih baik, train (3.05%) dan test (5.52%) serta selisih keduanya sekitar 2% alias tidak underfitting dan overfitting. 


# STLM

Seasonal Trend with Loess Model (STLM). Apabila dalam decompose biasa, dalam mendapatkan komponen trend dengan cara central moving average (CMA) dimana secara konsep setiap data yang ingin dirata-ratakan diberikan bobot yang sama sesuai ordo yang ditetapkan. Karena merata-ratakan data tengahnya hasilnya kita kehilangan data awal dan data akhirnya, sehingga ada beberapa informasi yang hilang. Ada salah satu cara untuk mendapatkan decompose data namun tetap mempertahankan informasi dari seluruh data yang kita miliki yaitu dengan menggunakan STL(Seasonal Trend with Loess). STL secara konsep akan melakukan smoothing terhadap data tetangga setiap masing-masing observasi dengan memberikan bobot yang lebih berat terhadap data yang dekat dengan observed data. Kekurangan dari STL hanya bisa melakukan decompose pada additive data, apabila terdapat multiplicative data dapat menggunakan transformasi log()[^12].

Untuk memodelkan hasil STL, kita bisa menerapkan STLM(Seasonal Trend with Loess Model) dimana kita bisa menerapkan metode exponential smoothing (ETS) dan ARIMA. Selain itu, STLM dapat digunakan sebagai alternative cara untuk menangkap seasonal yang belum bisa ditangkap oleh metode ETS dan ARIMA biasa.


## 1. Model Building

Dengan menggunakan informasi data train sales_train dan test sales_test, kita akan coba untuk membuat model dengan menggunakan metode stlm() dengan mengatur parameter method = "ets".

Parameter stlm() yang harus di atur:

- y : object time series
- s.window : pola seasonal yang ingin ditangkap
- method : metode forecast yang akan digunakan, tersedia ets dan arima
- modeling

```{r}
model_stlm <- stlm(y = train_dautonse, s.window = 12, method = "ets")
```


## 2. Forecasting

Melakukan forecast untuk 18 bulan mendatang

```{r}
forecast_stlm <- forecast(model_stlm, h = 18)
```


## 3. Visualization

```{r}
ts_dautonsa %>% autoplot(series = "actual") +
  autolayer(test_dautonse, series = "test data") +
  autolayer(forecast_stlm$mean, series = "forecast") +
  scale_color_manual(values = c("black", "blue", "firebrick"))
```

## 4. Evaluation

```{r}
accuracy(model_stlm$fitted, train_dautonse) # error train
```

```{r}
accuracy(forecast_stlm$mean, test_dautonse)
```

> Hasil forecast model **STLM (Seasonal Trend with Loess Model)** sudah dapat mengikuti pola data aktualnya. Cenderung hasil prediksi sudah mengikuti pola data meskipun masih terdapat beberapa titik yang belum mendekati data aktual. Selain itu, ukuran MAPE yang dihasilkan sudah lebih baik, train (2.69%) dan test (6.67%) serta selisih keduanya sekitar 4% alias tidak underfitting dan overfitting. 

# Choose The Best Model

Pada kesempatan ini kita fokus membandingkan model dengan metrik *Mean Absolute Percentage Error* (MAPE), alasannya relatif mudah dibandingkan karena satuannya persen. Kita mesti mempertimbangkan nilai MAPE ketika train dan test serta selisih keduanya.

```{r}
data.frame(
  Model = c("Model Simple Moving Average", 
            "Holtâ€™s Exponential Smoothing",
            "Seasonal ARIMA",
            "STLM"),
  Train_MAPE = c(7.43, 3.65, 3.05, 2.69),
  Test_MAPE = c(8.71, 5.88, 5.52, 6.67),
  Selisih = c(8.71-7.43, 5.88-3.65, 5.52-3.05, 6.67-2.69)
)
```


> Kalau kita lihat cenderung model `model_auto_sarima` memiliki MAPE train (3.05%) dan test (5.52%) relatif kecil dan selisih keduanya cukup baik. Jadi kita memutuskan untuk menggunakan algoritma SARIMA yaitu model `model_auto_sarima`.
 
# Assumption

Asumsi pada time series diujikan untuk mengukur apakah residual yang peroleh dari hasil modeling sudah cukup baik untuk menggambarkan dan menangkap informasi pada data. Mengapa menggunakan residual data? Karena dengan menggunakan residual data, kita dapat mendapatkan informasi dari data aktual maupun dari hasil prediksi menggunakan model. Metode forecasting yang baik menghasilkan nilai residual berikut ini:

Residual yang tidak berkorelasi. Apabila terdapat residual yang berkorelasi, artinya masih terdapat informasi yang tertinggal yang seharusnya digunakan untuk menghitung hasil forecast. Residual memiliki rata-rata 0.
Untuk memastikan bahwa residual yang dihasilkan memiliki kriteria diatas, maka terdapat asumsi untuk mengujinya.


## 1. No-autocorrelation Residual

Untuk mengecek ada/tidaknya autokorelasi pada hasil forecasting time series bisa menggunakan :

uji Ljung-box dengan menggunakan fungsi Box.test(residual model, type = "Ljung-Box)

H0: residual has no-autocorrelation
H1: residual has autocorrelation

yang diinginkan p-value > 0.05 (alpha), no-autocorrelation

```{r}
# menggunakan Ljung-Box test
Box.test(model_auto_sarima$residuals, type = "Ljung-Box")
```
> p-value > 0.05 (alpha) artinya gagal tolak H0, artinya residual/error pada data tidak terdapat autocorrelation.


## 2. Normality of Residual

H0: residual menyebar normal
H1: residual tidak menyebar normal

yang diinginkan p-value > 0.05 (alpha), residual menyebar normal

Untuk mengecek normality residual pada hasil forecasting time series kita bisa melakukan uji normality (shapiro test) dengan menggunakan fungsi shapiro.test(residual model)

```{r}
shapiro.test(model_auto_sarima$residuals)
```

```{r}
hist(model_auto_sarima$residuals, xlab = "Residuals", main = "Residual Model SARIMA")
```

> p-value < alpha artinya tolak H0, artinya residual/error pada data tidak menyebar normal.


# Conclusion

Kita telah melalui berbagai proses dalam pembuatan *Model Forecasting* yang dapat memperkirakan berapa nilai penjualan dimasa mendatang. Proses ini meliputi pendahuluan, persiapan dataset, persiapan model time series, mencoba 4 model time series, mengevaluasinya, mengecek asumsi hingga memutuskan model **Seasonal ARIMA** sebagai model forecasting kita. Harapannya melalui projek ini dapat menjadi referensi dalam membangun *Machine Learning* untuk melakukan forecasting sehingga dapat menjadi dasar dalam pengambilan keputusan secara efektif dan efisien. Sekian terima kasih banyak yang telah melihat projek ini. Saya juga menyukai masukan dan kolaborasi sehingga apabila ada masukan, saran, kritik atau untuk berkolaborasi dapat menghubungi lewat [Linkedin](https://www.linkedin.com/in/toni-andreas-s).



